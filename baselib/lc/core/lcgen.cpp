
#define LCFLAG_PROJECT "lcgen"
#define LCFLAG_VERSION "1.0.0.0"
#define LCFLAG_CVSTAG "LC 1.1.0.x"

#include "lcfw.h"
#include "cfgflag.h"
#include <vector>

const char * makefile =  "###########################################################################\n\
# Automatically generated by comake (1.0.0)  							  #\n\
###########################################################################\n\
\
#################设计系统参数#######################################\n\
WORKROOT	?=	%s\n\
target=%s\n\
PROJECT=%s\n\
VERSION=1.0.0\n\
CVSTAG=1.0.0\n\
CXXFLAGS=-DLCFLAG_PROJECT=\"\\\"$(PROJECT)\\\"\"\\\n\
	  -DLCFLAG_VERSION=\"\\\"$(VERSION)\\\"\"\\\n\
	  -DLCFLAG_CVSTAG=\"\\\"$(CVSTAG)\\\"\"\\\n\
	  -g -Wall -W -Winline -Wno-unused-parameter -Wno-unused-function\n\
\n\
###############lib 的32位 64位支持#################\n\
HARDWARE_PLATFORM := $(shell uname -m)\n\
ifeq ($(HARDWARE_PLATFORM),x86_64)\n\
	lib2=lib2-64\n\
	third=third-64\n\
else\n\
	lib2=lib2\n\
	third=third\n\
endif\n\
##########################################\n\
\n\
# 编译参数\n\
INCPATH =  -I. -I$(WORKROOT)/plclic/spreg/output//include/ \\\n\
		   -I$(WORKROOT)/plclic/comlog-plugin/output//include/ \\\n\
		   -I$(WORKROOT)/plclic/connectpool/output// \\\n\
		   -I$(WORKROOT)/plclic/nshead/output//include/ \\\n\
		   -I$(WORKROOT)/plclic/lc/output//include/ \\\n\
		   -I$(WORKROOT)/$(third)/pcre//include/ \\\n\
		   -I$(WORKROOT)/$(lib2)/bsl//include/ \\\n\
		   -I$(WORKROOT)/plclic/configure/output//include/ \\\n\
		   -I$(WORKROOT)/$(lib2)/ullib//include/\n\
LDFLAGS =  -L$(WORKROOT)/$(third)/pcre//lib/ \\\n\
		   -L$(WORKROOT)/plclic/connectpool/output// \\\n\
		   -L$(WORKROOT)/plclic/comlog-plugin/output//lib/ \\\n\
		   -L$(WORKROOT)/plclic/nshead/output// \\\n\
		   -L$(WORKROOT)/$(lib2)/bsl//lib/ \\\n\
		   -L$(WORKROOT)/$(lib2)/ullib//lib/ \\\n\
		   -L$(WORKROOT)/plclic/configure/output//lib/ \\\n\
		   -L$(WORKROOT)/plclic/lc/output//lib/ \\\n\
		   -L$(WORKROOT)/plclic/spreg/output//lib/\n\
LDLIBS = -llc -lcomlog -lconfig  -lspreg -lnshead -lconnectpool -lpcrecpp -lpcreposix -lpcre -lbsl  -lullib	\\\n\
		 -lpthread\n\
\n\
#start target\n\
first : all\n\
\n\
############# 默认推到公式\n\
.SUFFIXES: .c .cpp .cc .cxx .C .idl .des\n\
\n\
.cpp.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.cc.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.cxx.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.C.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.c.o:\n\
	$(CC) -c -o $@ $<  $(CFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.idl.cpp:\n\
	$(IDLCC) --ns=$(*F) -o $* $< $(CPPFLAGS) $(INCPATH)\n\
\n\
#############\n\
###cpp 支持\n\
%info : %\n\
	ccp $<\n\
#############\n\
\n\
\n\
###############编译目标\n\
all :  $(target) output \n\
.PHONY : all clean output\n\
\n\
SOURCES := $(wildcard *.cpp)\n\
HEADERS := *.h\n\
OBJS := $(SOURCES:.cpp=.o)\n\
\n\
$(target) : $(OBJS) \n\
	g++ $^ -o $@ -Xlinker \"-(\" $(LDFLAGS) $(LDLIBS) $(LINKFLAGS) -Xlinker \"-)\"\n\
\n\
output:\n\
	mkdir -p output\n\
	mkdir -p output/bin\n\
	cp -rf $(target) output/bin\n\
	`if [ -e \"conf\" ];then cp -rf conf output/ ;fi`\n\
\n\
clean:\n\
	-rm -rf $(OBJS) $(IDLSRCCPP) $(IDLSRCH) \n\
	-rm -rf $(target)\n\
	-rm -rf output\n\
	-rm -rf ccp_output.error   ccp_output_scm.xml  ccp_output.xml ccp_output.pclint  ccp_output.txt\n\
	\n\
\n\
ccpc:\n\
	ccp $(SOURCES) --formatter vim";


const char * makefile1 =  "###########################################################################\n\
# Automatically generated by comake (1.0.0)  							  #\n\
###########################################################################\n\
\
#################设计系统参数#######################################\n\
WORKROOT	?=	%s\n\
target=%s\n\
PROJECT=%s\n\
VERSION=1.0.0\n\
CVSTAG=1.0.0\n\
CXXFLAGS=-DLCFLAG_PROJECT=\"\\\"$(PROJECT)\\\"\"\\\n\
	  -DLCFLAG_VERSION=\"\\\"$(VERSION)\\\"\"\\\n\
	  -DLCFLAG_CVSTAG=\"\\\"$(CVSTAG)\\\"\"\\\n\
	  -g -Wall -W -Winline -Wno-unused-parameter -Wno-unused-function\n\
\n\
###############lib 的32位 64位支持#################\n\
HARDWARE_PLATFORM := $(shell uname -m)\n\
ifeq ($(HARDWARE_PLATFORM),x86_64)\n\
	lib2=lib2-64\n\
	third=third-64\n\
else\n\
	lib2=lib2\n\
	third=third\n\
endif\n\
##########################################\n\
\n\
# 编译参数\n\
INCPATH =  -I. -I$(WORKROOT)/plclic/spreg/output//include/ -I$(WORKROOT)/plclic/mcpack/output//include/ -I$(WORKROOT)/plclic/comlog-plugin/output//include/ -I$(WORKROOT)/plclic/bslext/output//include/ -I$(WORKROOT)/plclic/connectpool/output// -I$(WORKROOT)/$(third)/stlport// -I$(WORKROOT)/libsrc/bsl/output//include/ -I$(WORKROOT)/plclic/gm/galileo/output//include/ -I$(WORKROOT)/com/idlcompiler/output// -I$(WORKROOT)/plclic/uconv/output//include/ -I$(WORKROOT)/plclic/nshead/output//include/ -I$(WORKROOT)/plclic/lc/output//include/ -I$(WORKROOT)/$(third)/pcre//include/ -I$(WORKROOT)/$(lib2)/bsl//include/ -I$(WORKROOT)/plclic/configure/output//include/ -I$(WORKROOT)/$(lib2)/ullib//include/ -I$(WORKROOT)/plclic/idlcompiler/output//include/ \n\
LDFLAGS =  -L$(WORKROOT)/plclic/gm/galileo/output//lib/ -L$(WORKROOT)/plclic/idlcompiler/output//lib/ -L$(WORKROOT)/plclic/connectpool/output// -L$(WORKROOT)/$(third)/stlport// -L$(WORKROOT)/plclic/comlog-plugin/output//lib/ -L$(WORKROOT)/plclic/nshead/output// -L$(WORKROOT)/com/idlcompiler/output// -L$(WORKROOT)/libsrc/bsl/output//lib/ -L$(WORKROOT)/plclic/bslext/output//lib/ -L$(WORKROOT)/$(lib2)/bsl//lib/ -L$(WORKROOT)/$(lib2)/ullib//lib/ -L$(WORKROOT)/plclic/mcpack/output//lib/ -L$(WORKROOT)/plclic/configure/output//lib/ -L$(WORKROOT)/$(third)/pcre//lib/ -L$(WORKROOT)/plclic/uconv/output// -L$(WORKROOT)/plclic/lc/output//lib/ -L$(WORKROOT)/plclic/spreg/output//lib/ \n\
LDLIBS = -llc -lzookeeper_mt -lgalileo -lcomlog -lbsl_bml -lbsl_var_serializer -lbsl_var_scripting -lbsl_vs -lbsl_var_vscript -lbslext -lconnectpool -lconfig -lmcpack_idl -luconv -lmcpack -lspreg -lnshead -lullib -lbsl_utils -lbsl_archive -lbsl_pool -lbsl_exception -lbsl_check_cast -lbsl_ResourcePool -lbsl_var_utils -lbsl_var_implement -lbsl_var -lbsl -lpcre -lpcrecpp -lpcreposix -lpthread -lcrypto -lm\n\
\n\
#start target\n\
first : all\n\
\n\
############# 默认推到公式\n\
.SUFFIXES: .c .cpp .cc .cxx .C .idl .des\n\
\n\
.cpp.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.cc.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.cxx.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.C.o:\n\
	$(CXX) -c -o $@ $<  $(CXXFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.c.o:\n\
	$(CC) -c -o $@ $<  $(CFLAGS) $(CPPFLAGS) $(INCPATH)\n\
\n\
.idl.cpp:\n\
	$(IDLCC) --ns=$(*F) -o $* $< $(CPPFLAGS) $(INCPATH)\n\
\n\
#############\n\
###cpp 支持\n\
%info : %\n\
	ccp $<\n\
#############\n\
\n\
\n\
###############编译目标\n\
all :  $(target) output \n\
.PHONY : all clean output\n\
\n\
SOURCES := $(wildcard *.cpp)\n\
HEADERS := *.h\n\
OBJS := $(SOURCES:.cpp=.o)\n\
\n\
$(target) : $(OBJS) \n\
	g++ $^ -o $@ -Xlinker \"-(\" $(LDFLAGS) $(LDLIBS) $(LINKFLAGS) -Xlinker \"-)\"\n\
\n\
output:\n\
	mkdir -p output\n\
	mkdir -p output/bin\n\
	cp -rf $(target) output/bin\n\
	`if [ -e \"conf\" ];then cp -rf conf output/ ;fi`\n\
\n\
clean:\n\
	-rm -rf $(OBJS) $(IDLSRCCPP) $(IDLSRCH) \n\
	-rm -rf $(target)\n\
	-rm -rf output\n\
	-rm -rf ccp_output.error   ccp_output_scm.xml  ccp_output.xml ccp_output.pclint  ccp_output.txt\n\
	\n\
\n\
ccpc:\n\
	ccp $(SOURCES) --formatter vim";

void split(std::vector<bsl::string> &vec, const bsl::string &vecs)
{
	const char *ptr = vecs.c_str();
	char svrn[256];
	while (sscanf(ptr, "%s", svrn) == 1) {
		ptr += strlen(svrn);
		while (*ptr && (*ptr == ' ' || *ptr == '\t')) ++ptr;
		vec.push_back(svrn);
		ul_writelog(UL_LOG_TRACE, "push %s -- ", svrn);
	}
}

struct client_t
{
	bsl::string name;
	bsl::string list;
};

int main(int argc, char **argv)
{
	comcfg::Flag flag(lc_default_print_version);
	flag.init(argc, argv);
	if (!flag.opt().hasOption("d")) {
		flag.set_cfpath("./");
	}
	if (!flag.opt().hasOption("f")) {
		int pos = strlen(argv[0]);
		do {
			-- pos;
		} while (pos >= 0 && argv[0][pos] != '/');
		bsl::string conf = argv[0]+pos;
		conf.append(".conf");
		flag.set_cffile(conf);
	}

	bsl::string name = "example";
	bsl::string server = "query update";
	bsl::string cvs = "../../../";
    int clientversion = 1;
	std::vector<client_t> clts;
	if (flag.loadconfig() == 0) {
		flag.cfg("name").get_bsl_string(&name, "example");
		flag.cfg("servers").get_bsl_string(&server, "query update");
		flag.cfg("cvs").get_bsl_string(&cvs, "../../../");
        flag.cfg("clientversion").get_int32(&clientversion, 1);
        if (1 == clientversion) {
		try {
			for (int i=0; i<(int)flag.cfg("client").size(); ++i) {
				client_t c;
				
				c.name = flag.cfg("client")[i]["name"].to_bsl_string();
				
				c.list = flag.cfg("client")[i]["servers"].to_bsl_string();
				clts.push_back(c);
			}
		} catch (...) {
			ul_writelog(UL_LOG_DEBUG, "exception ");
		}
        }
        else {
		try {
			for (int i=0; i<(int)flag.cfg("client").size(); ++i) {
				client_t c;
				
				c.name = flag.cfg("client")[i]["name"].to_bsl_string();
				
				c.list = flag.cfg("client")[i]["services"].to_bsl_string();
				clts.push_back(c);
			}
		} catch (...) {
			ul_writelog(UL_LOG_DEBUG, "exception ");
		}
        }
	}
	bsl::string def = name;
	flag.opt("name").get_bsl_string(&name, def);
	def = server;
	flag.opt("servers").get_bsl_string(&server, def);
	def = cvs;
	flag.opt("cvs").get_bsl_string(&cvs, def);
    int temp_version = clientversion;
    flag.opt("clientversion").get_int32(&clientversion, temp_version);

	bsl::string cmd = "mkdir -p ";
	cmd.append(name);
	system(cmd.c_str());
	ul_writelog(UL_LOG_TRACE, "cmd = %s", cmd.c_str());
	cmd.append("/conf");
	system(cmd.c_str());

	bsl::string cmd1 = "mkdir -p ";
	cmd1.append(name);
	cmd1.append("/info");
	system(cmd1.c_str());
	
    bsl::string mk = name;
	mk.append("/Makefile");
	FILE *fmk = fopen(mk.c_str(), "w");
	if (fmk == NULL) {
		ul_writelog(UL_LOG_FATAL, "can't open %s to write", mk.c_str());
		return -1;
	}

    if (1 == clientversion) {
	    fprintf(fmk, makefile, cvs.c_str(), name.c_str(), name.c_str());
    } else {
	    fprintf(fmk, makefile1, cvs.c_str(), name.c_str(), name.c_str());
    }
	fclose(fmk);

	bsl::string file = name;
	file.append("/main.cpp");
	FILE *fp = fopen (file.c_str(), "w");
	if (fp == NULL) {
		ul_writelog(UL_LOG_FATAL, "can't open %s to write", file.c_str());
		return -1;
	}
	fprintf(fp, "#include \"lc.h\"\n#include \"cfgflag.h\"\n");
    if (1 != clientversion) {
	    fprintf(fp, "#include \"lcfw2.h\"\n");
    }
    fprintf(fp, "#include \"LcMonitor.h\"\n");
    fprintf(fp, "#include \"lc_server_monitor.h\"\n");
    fprintf(fp, "#include <bsl/var/String.h>\n");

    fprintf(fp, "bsl::var::Ref g_monitor_info;\n");
    fprintf(fp, "char g_proc_name[1024];\n");

    fprintf(fp, "bsl::var::IVar &get_service_monitor_list(bsl::ResourcePool &rp)\n{\n");
    fprintf(fp, "    return g_monitor_info;\n}\n");

    fprintf(fp, "void get_proc_name() \n{\n");
    fprintf(fp, "    pid_t pid = getpid();\n\
    char exec_file[1024];\n\
    char proc_name[1024]; \n\
    snprintf(exec_file, sizeof(exec_file), \"/proc/%%d/exe\", pid); \n\
    int ret = readlink(exec_file, proc_name, sizeof(proc_name)); \n\
    proc_name[ret] = 0; \n\
    //获取文件名 \n\
    char *p = strrchr(proc_name, '/'); \n\
    snprintf(g_proc_name, sizeof(g_proc_name), \"%%s\", p + 1); \n}\n");


	std::vector<bsl::string> svrs;
	split(svrs, server);
	for (size_t i=0; i<svrs.size(); ++i) {
		fprintf(fp, "/**\n *@%s server\n**/\n", svrs[i].c_str());
		fprintf(fp, "static int %s_server_callback()\n{\n",
				svrs[i].c_str());
		const char *body = "\
	nshead_t *req_head = (nshead_t *) lc_server_get_read_buf();\n\
	//nshead_t *res_head = (nshead_t *) lc_server_get_write_buf();\n\
	//void *req_buf = req_head+1;\n\
	//void *res_buf = res_head+1;\n\
	\n\
	lc_log_setbasic(LC_LOG_REQSVR, \"%%s\", req_head->provider);\n\
	lc_log_setbasic(LC_LOG_SVRNAME, \"%%s\", \"%s\");\n\
	//lc_log_setbasic(LC_LOG_CMDNO, \"%%d\", cmd_no);\n\
	\n\
	//res_head->body_len = 0;\n\
	return 0;\n";
		fprintf(fp, body, svrs[i].c_str());
		fprintf(fp, "}\n\n");
	}
	fprintf(fp, "/**\n *@brief timer\n**/\n");
	fprintf(fp, "static int monitor_timer(void *)\n{\n\tul_writelog(UL_LOG_NOTICE, \"call timer\");\n\treturn 0;\n}\n");
const char *mainfun = "/**\n\
 * @brief 注册main函数，支持命令行参数解析\n\
 * 请运行 ./xxxx -h 显示帮助\n\
**/\nint main(int argc, char **argv)\n{\n";
	fprintf(fp, mainfun);
	const char *head = "\
	lc_t * fw = lc_init(\"%s\", argc, argv);	//初始化框架\n\
	if (fw == NULL) { 	//返回0表示要退出\n\
		return 0; \n\
	}\n\
	//comcfg::CmdOption opt;//声明一个解析命令行的类\n\
	//opt.init(argc, argv, \"\");//想知道opt怎么使用的参考plclic/configure的使用\n\
	//opt[\"命令行的key名\"].to_cstr();//返回字符串，如果不知道是否存在，先调用opt.hasOption(char *)判断一下\n\n\
	lc_conf_data_t *conf = lc_open_conf(fw);	//打开配置文件\n\
	LCFW_ASSERT(conf != NULL, \"open configure %%s/%%s error\", fw->path, fw->file);\n\
\n\
	lcfw_open_galileo_log(fw);  //打开Galileo日志\n\
	//启动comlog\n\
	LCFW_ASSERT(lc_load_log(fw) == 0, \"open log error\");\n\
	lc_svr_vec_t *svrvec = lc_svr_vec_create();	//不会返回NULL，如果没内存了，程序自动退出\n\
	LCFW_ASSERT(svrvec != NULL, \"create lc_server_vec_error\");\n\
	//加载配置\n\
	\n";
	fprintf(fp, head, name.c_str());

    
    const char *moinfo = "\
    lc::LcMonitor *monitor = lc_load_monitor(fw);\n\
    LCFW_ASSERT(fw->conf_build || monitor != NULL, \"create LcMonitor error \");\n\n";
    fprintf(fp, moinfo);
	
    
    fprintf(fp, "\
    bsl::ResourcePool rp;\n");
    fprintf(fp, "\
    g_monitor_info = rp.create<bsl::var::Dict>();\n");

    const char *moinfo1 = "\
    get_proc_name();\n\
    g_monitor_info[g_proc_name] = rp.create<bsl::var::Dict>();\n\
    g_monitor_info[g_proc_name][\"__global\"] = rp.create<bsl::var::Dict>();\n\
    g_monitor_info[g_proc_name][\"__global\"][\"RUNNING_TIME\"] = rp.create<bsl::var::String>(\"模块运行时间\"); \n\
    g_monitor_info[g_proc_name][\"__global\"][\"PROGRAM_VERSION\"] = rp.create<bsl::var::String>(\"程序版本号\");\n\
    g_monitor_info[g_proc_name][\"__global\"][\"LIB_VERSION\"] = rp.create<bsl::var::String>(\"链接库版本\"); \n\
    g_monitor_info[g_proc_name][\"__global\"][\"DATA_VERSION\"] = rp.create<bsl::var::String>(\"数据版本\"); \n\
    int max_server_num = 0;\
    ";
    fprintf(fp, moinfo1);

    for (size_t i=0; i<svrs.size(); ++i) {
		const char *svrcf = "\
	//加载lcserver	%s\n\
	lc_server_t *%ssvr = lc_load_svr(fw, \"%s\");	//加载 %s server\n\
	LCFW_ASSERT(fw->conf_build || %ssvr != NULL, \"create %s server error\");\n\
	lc_server_setoptsock(%ssvr, LCSVR_NODELAY);\n\
	lc_server_set_callback(%ssvr, %s_server_callback);	//设置服务器回调\n\
	lc_svr_vec_add(svrvec, %ssvr, fw);	//把server添加到容器中统一管理\n\
    lc_server_set_monitor(%ssvr, monitor);\n\
    g_monitor_info[g_proc_name][lc_server_get_server_name(%ssvr)] = get_monitor_list(rp);\n\
    if (max_server_num < lc_server_get_threadnum(%ssvr)) {\n\
        max_server_num = lc_server_get_threadnum(%ssvr);\n\
    }\n\
	\n";
		const char *n = svrs[i].c_str();
		fprintf(fp, svrcf, n, n, n, n, n, n, n, n, n, n, n, n, n, n);
	}

    fprintf(fp, "    monitor->set_query_item_callback(get_service_monitor_list);");

	fprintf(fp, "	//加载lcclient\n");
    if (1 == clientversion) {
	    for (size_t i=0; i<clts.size(); ++i) {
		    const char * cs = "\
	        lc_client_t *%sclt = lc_load_clt(fw, \"%s\", \"%s\"); //加载client客户端\n\
	        LCFW_ASSERT(fw->conf_build || %sclt != NULL, \"create %s client error\");\n\n";
		    const char *n = clts[i].name.c_str(), *s = clts[i].list.c_str();
		    fprintf(fp, cs, n, n, s, n, n);
	    }
    } else {
	    
		    const char * cs = "\
	lc::LcClientManager *lcmgr = lc_load_clt2(fw, \"%s\", \"%s\"); //加载client客户端\n\
	LCFW_ASSERT(fw->conf_build || lcmgr != NULL, \"create %s client error\");\n";
		    
            const char *n = "all";
            const char *s = "all";
		    fprintf(fp, cs, n, s, n);
        
    }

	const char *logical = "\
	//在这里填写你要加载的配置\n\
\n\
	//配置加载完毕, 如果是自动生成配置模式，到这里就应该退出程序了\n\
	lc_builddone_exit(fw);\n\
\n\
	LCFW_ASSERT(lc_svr_vec_run(svrvec) == 0, \"run server vectors error\");	//启动server\n";

	fprintf(fp, logical);

	const char *timer="\
	lc_timer_task_t *timer = lc_create_timer_task();\n\
	LCFW_ASSERT(timer!=0, \"create timer task error\");\n\
	LCFW_ASSERT(lc_add_timer_task(timer, monitor_timer, NULL, 10000/*ms*/) == 0, \n\
			\"start monitor callback\");\n\
	LCFW_ASSERT(lc_run_timer_task(timer) >0, \"run timer error\");\n\n\
	\n";
	fprintf(fp, timer);

	const char *des = "\
    monitor->run();\n\
	lc_svr_vec_join(svrvec);	//等待server\n\
    monitor->join(); \n\
	lc_svr_vec_destroy(svrvec);	//销毁server\n\
	lc_join_timer_task(timer);	//等待定时器\n\
	lc_destroy_timer_task(timer);	//销毁定时器\n\
\n";
	fprintf(fp, des);
    if (1 == clientversion) {
	    for (size_t i=0; i<clts.size(); ++i) {
		    fprintf(fp, "	lc_client_close(%sclt);\n", clts[i].name.c_str());
	    }
    } else {
        fprintf(fp, "	lcmgr->close();\n");
    }
	
	const char *end = "\
	lc_log_close();\n\
	lcfw_close_galileo_log();\n\
\n\
	lc_close(fw);\n\
	return 0;\n\
}\n";

	fprintf(fp, end);
	fclose(fp);

	return 0;
}


